---
title: "Correlation analysis of ZIM3's flanking motifs"
author: Zheng Zuo
date: "Aug 21, 2022"
output:
  html_document:
    df_print: paged
    theme: lumen
    highlight: pygments
    toc: yes
    toc_float: yes
  pdf_document:
    toc: yes
---

## Introduction
This Notebook is used to show that it is not only feasible, but also necessary to use such an fixed-core analysis method to extract the full specificity of long, tandem zinc finger proteins (ZFPs). Briefly, I generated the extended motif profiles based on different 8-mer anchor sites, including the AACAGAAA consensus and all its 24 single variants. Using correlation analysis and hiechical clustering, it is clear that no more than eight cores can serve as "good" anchors to produce longer specificity profiles cross-validated by footprinting profiles, which also lends evidence to our proposed "dependent recognition", or "Anchor" model about the recognition of tandem zinc finger proteins. This analysis workflow could be generalized to analyze other long ZFPs also.

![](Figure 5 (ZIM3).png)
```{r message=FALSE, warning=FALSE, include=FALSE}
library(dplyr)
library(magrittr)
library(ggplot2)
library(GenomicRanges)
library(BSgenome.Hsapiens.UCSC.hg38)
library(TFCookbook)
```

### Parameters and functions used in this analysis workflow
```{r message=FALSE, warning=FALSE}
border_width <- 40
upstream_flank <- 7
downstream_flank <- 18

ZIM3.peaks <- genomation::readBed("data/ZIM3_peaks.narrowPeak")

Exo.plus = "data/ZIM3.plus.bigwig"
Exo.minus= "data/ZIM3.minus.bigwig"
```


```{r message=FALSE, warning=FALSE, include=FALSE}
countExo <- function(Sites){
  colNum  = nchar(anchor)+2*border_width
  windows = promoters(Sites, upstream = border_width,downstream =nchar(anchor)+border_width)
  N = length(Sites)
  
  if(!isEmpty(import.bw(Exo.plus, which = windows))){
      Reads.plus <- genomation::ScoreMatrix(target = Exo.plus, strand.aware = TRUE, unique = FALSE,
                                            windows= windows)@.Data %>% matrix(ncol = colNum)}
  else
      Reads.plus <- matrix(0L, nrow = length(Sites), ncol = colNum)
      
  
  if(!isEmpty(import.bw(Exo.minus, which = windows))){
      Reads.minus<- genomation::ScoreMatrix(target = Exo.minus, strand.aware = TRUE, unique=FALSE,
                              windows= windows)@.Data %>% matrix(ncol = colNum)}
  else
      Reads.minus<- matrix(0L, nrow = length(Sites), ncol = nchar(anchor)+2*border_width)
 
  Reads.Forward = vector(length = N)
  Reads.Forward[which(Sites@strand=="+")] = .rowSums(Reads.plus[which(Sites@strand=="+"), 1:(border_width+nchar(anchor))],
                                                     m = length(which(Sites@strand=="+")),
                                                     n = (border_width+nchar(anchor)))
  Reads.Forward[which(Sites@strand=="-")] = .rowSums(Reads.minus[which(Sites@strand=="-"), 1:(border_width+nchar(anchor))],
                                                     m = length(which(Sites@strand=="-")),
                                                     n = (border_width+nchar(anchor)))
  Reads.Reverse = vector(length = N)
  Reads.Reverse[which(Sites@strand=="+")] = .rowSums(Reads.minus[which(Sites@strand=="+"), (border_width+1):(2*border_width+nchar(anchor))],
                                                     m = length(which(Sites@strand=="+")),
                                                     n = (border_width+nchar(anchor)))
  Reads.Reverse[which(Sites@strand=="-")] = .rowSums(Reads.plus[which(Sites@strand=="-"), (border_width+1):(2*border_width+nchar(anchor))],
                                                     m = length(which(Sites@strand=="-")),
                                                     n = (border_width+nchar(anchor)))
  
  return(Reads.Forward+Reads.Reverse)
}

anchorModel <- function(anchor, method = "linear", lambda) {
  # Finding all anchor sites within ZNF483 ChIP-exo peaks
  Sites <- TFCookbook::matchSite(site = anchor,
                                      subject = ZIM3.peaks,
                                      genome = "hg38")

  Sites$exo_count = countExo(Sites)
  
  Sites$Sequence  = BSgenome::getSeq(x = BSgenome.Hsapiens.UCSC.hg38,
                                     names = promoters(Sites,
                                                       upstream = upstream_flank,
                                                       downstream = nchar(anchor)+downstream_flank),
                                     as.character = TRUE)
  Sites %<>%
    subset(exo_count>0) %>%
    as_tibble() %>%
    mutate(Energy = -log(exo_count))

  if(method == "linear")
    TFCookbook::buildEnergyModel(data = Sites, method = "linear")%>% return
  else if(missing(lambda))
    TFCookbook::buildEnergyModel(data = Sites, method = method)  %>% return
  else{
    TFCookbook::buildEnergyModel(data = Sites, method = method, lambda = lambda) %>% return 
  }
}

```


## Inferring flanking motifs based on prefixed intact core
```{r eval = FALSE}
Model.AACAGAAA = anchorModel("AACAGAAA", method = "linear")

#save(list = "Model.AACAGAAA", file = "ZIM3.Model.AACAGAAA.RData")
Model.AACAGAAA %>% as.PEM() %>%
  TFCookbook::addAnchorMatrix(anchor = "AACAGAAA", position = 8, height = .15) %>%
  TFCookbook::plotEnergyLogo() +
  theme(axis.title.x = element_blank(),
        axis.text.x  = element_blank()) -> plot.AACAGAAA

#ggsave(plot = plot.AACAGAAA, filename = "PEM.AACAGAAA.svg", width = 5.06, height = 1)

```
![](./PEM.AACAGAAA.svg)

## Inferring flanking motifs based on different anchor sites

```{r eval=FALSE, message=FALSE, warning=FALSE}
require(furrr)  # Do multi-core parallel computing
plan(multiprocess)

singleVariants <- tibble(Sequence = TFCookbook::kmer(8)) %>%
  mutate(Mismatch = TFCookbook::countMismatch(Sequence, "AACAGAAA")) %>%
  filter(Mismatch <= 1) %>%# Enumerating all single variants of GAAGCG anchor sites
  mutate(Model = purrr::map(Sequence, anchorModel)) %>% # Extracting extended specificity info based on each anchor site
  mutate(Anchors.count = purrr::map_int(Model, function(model) length(model$residuals)),
         PEM           = purrr::map(Model, as.PEM))# Counting the number of anchors found within ChIP-exo peaks
```


```{r echo=FALSE}
#save(list = "singleVariants", file = "ZIM3.Models.RData")
load("data/ZIM3.Models.RData")

singleVariants %>%
  arrange(desc(Anchors.count))
```

## Correlation analysis of flanking motifs of all single variants

### Building Heatmap and Hiechical clustering based on the correlation coefficients between pairs of extended motifs
```{r fig.height=5.5, fig.width=5, message=FALSE, warning=FALSE}
Heatmap_data <- sapply(singleVariants$Model, function(x) x$coefficients[-1]) %>%
#Heatmap_data <- sapply(singleVariants$Model, function(x) x$coefficients[c(62:91)]) %>%
  na.omit() %>%
  as.data.frame()

colnames(Heatmap_data) <- singleVariants$Sequence

Heatmap.matrix = 1-cor(Heatmap_data)

Heatmap <- pheatmap::pheatmap(Heatmap.matrix, fontfamliy = "mono")

#ggsave("Heatmap_ZIM3.svg", plot=Heatmap, height = 5, width = 4.8)
```


## Ploting extended motif for each anchor site based on the ChIP-exo reads in flanking regions

```{r fig.height=10, fig.width=4}
logos <- purrr::map2(
  singleVariants$Sequence,
  singleVariants$PEM,
  function(anchor, PEM) {
    -(PEM %>%
      TFCookbook::addAnchorMatrix(anchor = anchor, position = 8, height = max(abs(PEM), na.rm = TRUE)))
  }
)[Heatmap$tree_row$order]


(ggplot() +
  ggseqlogo::geom_logo(logos, method="custom", seq_type = "dna",
                       col_scheme = ggseqlogo::make_col_scheme(chars=c('A', 'C', 'G', 'T'),
                                            cols=c("#0E927B", "#59A9D8", "#DC9514", "#1A1A1A"))
  )  + 
  ggseqlogo::theme_logo() +
 # scale_x_continuous(breaks = seq(1,17,2), label = seq(1,17,2)) +
  theme(axis.text.x = element_blank(),
        axis.title.x= element_blank()) +
  facet_wrap(~seq_group, ncol=1, scales='free_y', strip.position = "right") -> logos
)


#singleVariants$Sequence[Heatmap$tree_row$order]
#ggsave("ZIM3_logos.svg", plot=logos, width=2.5, height=5, units="in")
```
